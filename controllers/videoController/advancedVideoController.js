require('dotenv').config();
const path = require('path');
const fs = require('fs');
const { uploadFile } = require(path.resolve(__dirname, '../../services/firebaseService.js'));

const { execSync } = require('child_process');
const axios = require('axios');
const { generateScriptByVertexAI } = require('../../services/vertexService');
const { VIETNAMESE_VOICES } = require('../../services/textToSpeechService');
const textToSpeech = require('@google-cloud/text-to-speech');
const multer = require('multer');
const os = require('os');
const util = require('util');
const videoModel = require('../../models/videoModel');   // ƒë∆∞·ªùng d·∫´n tu·ª≥ d·ª± √°n
const { addBackgroundMusic } = require('../../services/videoGeneratorService'); // ƒë∆∞·ªùng d·∫´n ƒë·∫£m b·∫£o ƒë√∫ng

// ngay ƒë·∫ßu file (ƒë√£ c√≥ multer) th√™m c·∫•u h√¨nh ch·∫•p nh·∫≠n audio


// Thi·∫øt l·∫≠p multer cho vi·ªác t·∫£i l√™n file
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const tempDir = path.join(__dirname, '../../public/temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    cb(null, tempDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, 'user_upload_' + uniqueSuffix + ext);
  }
});

const fileFilter = (req, file, cb) => {
  // Ch·ªâ ch·∫•p nh·∫≠n c√°c file ·∫£nh
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Ch·ªâ ch·∫•p nh·∫≠n file h√¨nh ·∫£nh!'), false);
  }
};
const audioUpload = multer({
  storage,
  limits:{fileSize: 20*1024*1024},           // 20 MB ƒë·ªß r·ªông
  fileFilter:(req,file,cb)=>{
    if(file.mimetype.startsWith('audio/')) cb(null,true);
    else cb(new Error('Ch·ªâ ch·∫•p nh·∫≠n file √¢m thanh'),false);
  }
});
function convertUrlToFilePath(url) {
  if (!url) return null;
  if (/^https?:\/\//i.test(url)) {
    url = new URL(url).pathname;          // b·ªè domain
  }
  if (url.startsWith('/')) {
    return path.join(__dirname, '../../public', url.slice(1));
  }
  return path.isAbsolute(url)
    ? url
    : path.join(__dirname, '../../public', url);
}

/* --- API UPLOAD AUDIO --- */
const uploadAudioForPart = async (req,res)=>{
  try{
      const {sessionId,partId} = req.body;
      if(!sessionId||!partId) throw new Error('Thi·∫øu sessionId / partId');

      // ki·ªÉm tra session
      if(!req.session?.videoPreparation
          || req.session.videoPreparation.sessionId !== sessionId){
          throw new Error('Phi√™n l√†m vi·ªác kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
      }

      // ƒë∆∞·ªùng d·∫´n ƒë√£ ƒë∆∞·ª£c multer l∆∞u v√†o req.file.path
      const part = req.session.videoPreparation.scriptParts
                    .find(p=>p.id===partId);
      if(!part)   throw new Error('Kh√¥ng t√¨m th·∫•y part');

      const rel = `/temp/${path.basename(req.file.path)}`;
part.audioPath = rel;


      return res.json({
          success:true,
          audioPath:`/temp/${path.basename(req.file.path)}`,
          audioPath: rel,
  mime :'audio/mpeg'
          
      });
  }catch(err){
      console.error('uploadAudioForPart',err);
      res.status(500).json({success:false, error: err.message});
  }
};


const upload = multer({
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  },
  fileFilter: fileFilter
});

// ƒê∆∞·ªùng d·∫´n ƒë·∫øn file credentials cho Text-to-Speech
const ttsCredentialsPath = path.join(__dirname, '../../text to speed.json');

// Kh·ªüi t·∫°o client Text-to-Speech
let ttsClient;
try {
  ttsClient = new textToSpeech.TextToSpeechClient({
    keyFilename: ttsCredentialsPath
  });
  console.log('‚úì ƒê√£ kh·ªüi t·∫°o Text-to-Speech client th√†nh c√¥ng');
} catch (error) {
  console.error('‚ùå L·ªói kh·ªüi t·∫°o Text-to-Speech client:', error.message);
}


/**
 * Tr√≠ch xu·∫•t c√°c ph·∫ßn t·ª´ k·ªãch b·∫£n
 */
function extractScriptParts(script) {
  const parts = [];

  // Chu·∫©n h√≥a script ƒë·ªÉ ƒë·∫£m b·∫£o d·∫•u xu·ªëng d√≤ng nh·∫•t qu√°n
  const normalizedScript = script.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

  // Regex ƒë·ªÉ t√¨m c√°c ph·∫ßn trong k·ªãch b·∫£n (l√†m linh ho·∫°t h∆°n) - h·ªó tr·ª£ c·∫£ ƒë·ªãnh d·∫°ng m·ªõi v√† c≈©
  const partRegex = /((?:##?\s*)?PH·∫¶N\s+(\d+|CU·ªêI|1:\s*HOOK)[\s\S]*?)(?:(?:\*\*)?L·ªùi\s*tho·∫°i:?(?:\*\*)?\s*)([\s\S]*?)(?:(?:(?:\*\*)?H√¨nh\s*·∫£nh:?(?:\*\*)?\s*)([\s\S]*?))?(?=\s*(?:(?:##?\s*)?PH·∫¶N|\s*(?:##?\s*)?PH·∫¶N CU·ªêI)|\s*$)/gi;

  console.log('üîç ƒêang ph√¢n t√≠ch k·ªãch b·∫£n...');
  console.log('üìù ƒêo·∫°n ƒë·∫ßu k·ªãch b·∫£n:', normalizedScript.substring(0, 200));

  let match;
  while ((match = partRegex.exec(normalizedScript)) !== null) {
    const [fullMatch, sectionHeader, part, text, image] = match;

    // Th√™m log ƒë·ªÉ ki·ªÉm tra t·ª´ng match
    console.log(`‚úÖ T√¨m th·∫•y PH·∫¶N ${part}:`);
    console.log(`   L·ªùi tho·∫°i: ${text ? text.substring(0, 30) + '...' : 'kh√¥ng c√≥'}`);
    console.log(`   H√¨nh ·∫£nh: ${image ? 'c√≥' : 'kh√¥ng c√≥'}`);

    parts.push({
      part: part.trim(),
      text: text ? text.trim() : '',
      image: image ? image.trim() : ''
    });
  }

  return parts;
}

/**
 * Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i
 */
async function convertTextToSpeech(text, outputPath, voiceId = VIETNAMESE_VOICES.FEMALE_NEURAL_A) {
  try {
    if (!text || text.trim() === '') {
      throw new Error('VƒÉn b·∫£n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
    }

    console.log(`üîä ƒêang chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i v·ªõi gi·ªçng ${voiceId}...`);

    // T·∫°o th∆∞ m·ª•c ƒë·∫ßu ra n·∫øu ch∆∞a t·ªìn t·∫°i
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // C·∫•u h√¨nh request
    const request = {
      input: { text },
      voice: {
        languageCode: 'vi-VN',
        name: voiceId,
      },
      audioConfig: {
        audioEncoding: 'MP3',
        pitch: 0,
        speakingRate: 1.0,
        volumeGainDb: 0.0
      },
    };

    // G·ªçi API ƒë·ªÉ chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i
    const [response] = await ttsClient.synthesizeSpeech(request);

    // Ghi file √¢m thanh
    await util.promisify(fs.writeFile)(outputPath, response.audioContent, 'binary');

    console.log(`‚úì ƒê√£ t·∫°o file gi·ªçng n√≥i t·∫°i: ${outputPath}`);
    return outputPath;
  } catch (error) {
    console.error('‚ùå L·ªói khi chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i:', error);
    throw error;
  }
}

/**
 * Ph√¢n t√≠ch k·ªãch b·∫£n v√† t·∫°o file √¢m thanh cho t·ª´ng ph·∫ßn
 */
async function createAudioForScript(script, outputDir, voiceId = VIETNAMESE_VOICES.FEMALE_NEURAL_A) {
  try {
    // Ki·ªÉm tra v√† t·∫°o th∆∞ m·ª•c ƒë·∫ßu ra
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Tr√≠ch xu·∫•t c√°c ph·∫ßn t·ª´ k·ªãch b·∫£n
    const scriptParts = extractScriptParts(script);
    console.log(`ƒê√£ t√¨m th·∫•y ${scriptParts.length} ph·∫ßn trong k·ªãch b·∫£n`);

    // T·∫°o √¢m thanh cho t·ª´ng ph·∫ßn
    const audioResults = [];

    for (let i = 0; i < scriptParts.length; i++) {
      const part = scriptParts[i];
      const outputPath = path.join(outputDir, `part_${i + 1}.mp3`);

      console.log(`ƒêang x·ª≠ l√Ω ph·∫ßn ${i + 1}/${scriptParts.length}: "${part.text.substring(0, 30)}..."`);

      try {
        const audioPath = await convertTextToSpeech(part.text, outputPath, voiceId);
        audioResults.push({
          ...part,
          audioPath
        });
      } catch (error) {
        console.error(`L·ªói khi x·ª≠ l√Ω ph·∫ßn ${i + 1}:`, error.message);
        // Ti·∫øp t·ª•c v·ªõi ph·∫ßn ti·∫øp theo n·∫øu c√≥ l·ªói
      }
    }

    console.log(`‚úì ƒê√£ t·∫°o ${audioResults.length}/${scriptParts.length} file √¢m thanh`);
    return audioResults;
  } catch (error) {
    console.error('‚ùå L·ªói khi t·∫°o √¢m thanh cho k·ªãch b·∫£n:', error);
    throw error;
  }
}

/**
 * Tr√≠ch xu·∫•t t·ª´ kh√≥a t·ª´ m√¥ t·∫£ h√¨nh ·∫£nh
 */
function extractKeywordsFromDescription(description) {
  if (!description) return [];

  // Danh s√°ch t·ª´ kh√¥ng mang nhi·ªÅu √Ω nghƒ©a t√¨m ki·∫øm
  const stopWords = ['v√†', 'ho·∫∑c', 'c·ªßa', 'v·ªõi', 'trong', 'ngo√†i', 'tr√™n', 'd∆∞·ªõi', 'm·ªôt', 'c√≥', 'l√†', 'c√°c', 'nh·ªØng',
    'ƒë∆∞·ª£c', 's·∫Ω', 'ƒëang', 'ƒë√£', 'n√†y', 'khi', 'v·ªÅ', 'nh∆∞', 'c√≥ th·ªÉ', 't·∫°i', 'b·ªüi', 'v√¨', 't·ª´', 'ƒë·ªÉ', 'ƒë·∫øn'];

  // T√°ch t·ª´ v√† l·ªçc
  const words = description
    .toLowerCase()
    .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3 && !stopWords.includes(word));

  // L·∫•y c√°c t·ª´/c·ª•m t·ª´ quan tr·ªçng
  const importantWords = [];
  const matches = description.match(/(?:"([^"]+)"|\(([^)]+)\)|([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+))/g) || [];

  // Th√™m t·ª´/c·ª•m t·ª´ quan tr·ªçng
  matches.forEach(match => {
    const cleanMatch = match.replace(/["()]/g, '').trim();
    if (cleanMatch.length > 3) {
      importantWords.push(cleanMatch);
    }
  });

  // K·∫øt h·ª£p t·ª´ quan tr·ªçng v√† t·ª´ d√†i
  const keywords = [...new Set([...importantWords, ...words.filter(w => w.length > 5).slice(0, 5)])];
  return keywords.slice(0, 3); // Gi·ªõi h·∫°n 3 t·ª´ kh√≥a cho m·ªói m√¥ t·∫£
}

/**
 * T·∫£i h√¨nh ·∫£nh t·ª´ Unsplash d·ª±a tr√™n t·ª´ kh√≥a
 */
async function downloadImagesForKeywords(keywords, tempDir) {
  // T·∫°o th∆∞ m·ª•c l∆∞u tr·ªØ t·∫°m th·ªùi n·∫øu ch∆∞a t·ªìn t·∫°i
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
  }

  const imageFiles = [];

  // T·∫°o ·∫£nh cho t·ª´ng t·ª´ kh√≥a ho·∫∑c m√¥ t·∫£ b·∫±ng imageController API
  for (const keyword of keywords) {
    try {
      // Hi·ªÉn th·ªã ph·∫ßn ƒë·∫ßu c·ªßa t·ª´ kh√≥a/m√¥ t·∫£ n·∫øu d√†i
      const displayKeyword = keyword.length > 50 ? `${keyword.substring(0, 50)}...` : keyword;
      console.log(`üñºÔ∏è ƒêang t·∫°o ·∫£nh cho: ${displayKeyword}`);

      // Th√™m ƒë·ªô tr·ªÖ tr∆∞·ªõc khi g·ªçi API ƒë·ªÉ tr√°nh rate limit (tƒÉng l√™n 30 gi√¢y)
      await new Promise(resolve => setTimeout(resolve, 30000));

      // N·∫øu keyword l√† m√¥ t·∫£ d√†i, th√™m c√°c t·ª´ kh√≥a n√¢ng cao ch·∫•t l∆∞·ª£ng
      let prompt = keyword;
      if (keyword.length > 30) {
        prompt = `${keyword}, high quality, detailed, clear image, sharp focus`;
      }

      // L·∫•y th√¥ng tin t·ªâ l·ªá khung h√¨nh t·ª´ session n·∫øu c√≥
      let aspectRatio = '16:9';
      try {
        if (req && req.session && req.session.videoPreparation && req.session.videoPreparation.aspectRatio) {
          aspectRatio = req.session.videoPreparation.aspectRatio;
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y aspectRatio t·ª´ session, s·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh 16:9');
      }

      // G·ªçi API imageController ƒë·ªÉ t·∫°o ·∫£nh v·ªõi prompt n√¢ng cao
      const response = await axios.post('http://localhost:3000/api/image/generate', {
        prompt: prompt,
        modelType: 'standard', // C√≥ th·ªÉ ch·ªçn 'ultra', 'standard', ho·∫∑c 'fast' t√πy nhu c·∫ßu
        imageCount: 1,
        aspectRatio: aspectRatio
      });

      if (response.data.success && response.data.images && response.data.images.length > 0) {
        // L∆∞u ·∫£nh v√†o th∆∞ m·ª•c t·∫°m
        const filePath = path.join(tempDir, `${keyword.replace(/\s+/g, '_')}_${Date.now()}.jpg`);

        // Ki·ªÉm tra lo·∫°i d·ªØ li·ªáu h√¨nh ·∫£nh tr·∫£ v·ªÅ
        if (response.data.images[0].type === 'base64') {
          // N·∫øu l√† d·ªØ li·ªáu base64, chuy·ªÉn th√†nh file
          fs.writeFileSync(filePath, Buffer.from(response.data.images[0].imageData, 'base64'));
        } else if (response.data.images[0].type === 'url') {
          // N·∫øu l√† URL, t·∫£i file v·ªÅ
          const imgResponse = await axios.get(response.data.images[0].imageData, { responseType: 'arraybuffer' });
          fs.writeFileSync(filePath, Buffer.from(imgResponse.data));
        }

        // Th√™m v√†o danh s√°ch ·∫£nh ƒë√£ t·∫°o
        imageFiles.push({
          keyword,
          path: filePath
        });

        console.log(`‚úÖ ƒê√£ t·∫°o th√†nh c√¥ng ·∫£nh cho t·ª´ kh√≥a: ${keyword}`);
      } else {
        throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ·∫£nh t·ª´ imageController API');
      }
    } catch (error) {
      console.error(`‚ùå L·ªói khi t·∫°o ·∫£nh cho t·ª´ kh√≥a ${keyword}:`, error.message);
      // Kh√¥ng s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p d·ª± ph√≤ng, ch·ªâ ghi log l·ªói v√† ti·∫øp t·ª•c v·ªõi t·ª´ kh√≥a ti·∫øp theo
    }
  }

  // N·∫øu kh√¥ng t·∫°o ƒë∆∞·ª£c ·∫£nh n√†o, s·ª≠ d·ª•ng ·∫£nh m·∫∑c ƒë·ªãnh t·ª´ th∆∞ m·ª•c public/image
  if (imageFiles.length === 0) {
    console.log('‚ö†Ô∏è S·ª≠ d·ª•ng ·∫£nh m·∫∑c ƒë·ªãnh do kh√¥ng t·∫°o ƒë∆∞·ª£c ·∫£nh t·ª´ t·ª´ kh√≥a');
    const defaultImages = [
      path.join(__dirname, '../../public/image/image1.png'),
      path.join(__dirname, '../../public/image/image2.png')
    ];

    for (const img of defaultImages) {
      if (fs.existsSync(img)) {
        imageFiles.push({
          keyword: 'default',
          path: img
        });
      }
    }
  }

  return imageFiles;
}

/**
 * T·∫£i h√¨nh ·∫£nh cho t·ª´ng ph·∫ßn k·ªãch b·∫£n
 */
async function downloadImagesForScriptParts(scriptParts, tempDir) {
  const results = [];

  // T·∫£i ·∫£nh cho t·ª´ng ph·∫ßn d·ª±a tr√™n m√¥ t·∫£
  for (const part of scriptParts) {
    // S·ª≠ d·ª•ng m√¥ t·∫£ h√¨nh ·∫£nh n·∫øu c√≥
    if (part.image && part.image.trim() !== '') {
      // S·ª≠ d·ª•ng to√†n b·ªô m√¥ t·∫£ h√¨nh ·∫£nh
      const imageDescription = part.image.trim();
      console.log(`üñºÔ∏è T·∫£i h√¨nh ·∫£nh v·ªõi m√¥ t·∫£ ƒë·∫ßy ƒë·ªß: ${imageDescription}`);
      
      // T·∫°o m·∫£ng ch·ª©a m·ªôt ph·∫ßn t·ª≠ l√† to√†n b·ªô m√¥ t·∫£
      const fullDescription = [imageDescription];
      
      // T·∫£i h√¨nh ·∫£nh v·ªõi m√¥ t·∫£ ƒë·∫ßy ƒë·ªß
      const images = await downloadImagesForKeywords(fullDescription, tempDir);
      if (images.length > 0) {
        results.push({
          ...part,
          imagePath: images[0].path
        });
        continue;
      }
      
      // N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c ·∫£nh v·ªõi m√¥ t·∫£ ƒë·∫ßy ƒë·ªß, th·ª≠ v·ªõi t·ª´ kh√≥a tr√≠ch xu·∫•t
      console.log(`‚ö†Ô∏è Kh√¥ng t√¨m ƒë∆∞·ª£c ·∫£nh v·ªõi m√¥ t·∫£ ƒë·∫ßy ƒë·ªß, th·ª≠ v·ªõi t·ª´ kh√≥a`);
      const keywords = extractKeywordsFromDescription(part.image);
      if (keywords.length > 0) {
        const keywordImages = await downloadImagesForKeywords(keywords, tempDir);
        if (keywordImages.length > 0) {
          results.push({
            ...part,
            imagePath: keywordImages[0].path
          });
          continue;
        }
      }
    }

    // N·∫øu kh√¥ng c√≥ m√¥ t·∫£ ho·∫∑c kh√¥ng t√¨m ƒë∆∞·ª£c ·∫£nh, d√πng vƒÉn b·∫£n ƒë·ªÉ tr√≠ch xu·∫•t t·ª´ kh√≥a
    const textKeywords = part.text
      .split(/\s+/)
      .filter(word => word.length > 4)
      .filter(word => !['nh∆∞', 'nh∆∞ng', 'ho·∫∑c', 'nh·ªØng', 'ƒë∆∞·ª£c', 'trong', 'c√πng'].includes(word.toLowerCase()))
      .slice(0, 2);

    if (textKeywords.length > 0) {
      const images = await downloadImagesForKeywords(textKeywords, tempDir);
      if (images.length > 0) {
        results.push({
          ...part,
          imagePath: images[0].path
        });
        continue;
      }
    }

    // N·∫øu v·∫´n kh√¥ng c√≥ ·∫£nh, th√™m ph·∫ßn kh√¥ng c√≥ ·∫£nh
    results.push({
      ...part,
      imagePath: null
    });
  }

  // N·∫øu kh√¥ng c√≥ ·∫£nh cho b·∫•t k·ª≥ ph·∫ßn n√†o, t·∫£i m·ªôt s·ªë ·∫£nh m·∫∑c ƒë·ªãnh
  if (results.every(r => !r.imagePath)) {
    const defaultImages = await downloadImagesForKeywords(['presentation', 'background', 'minimal'], tempDir);

    // G√°n ·∫£nh m·∫∑c ƒë·ªãnh cho c√°c ph·∫ßn
    for (let i = 0; i < results.length; i++) {
      const imgIndex = i % defaultImages.length;
      results[i].imagePath = defaultImages[imgIndex]?.path || null;
    }
  }

  return results;
}
// Th√™m h√†m l·∫•y th·ªùi l∆∞·ª£ng audio b·∫±ng ffprobe
function getAudioDuration(audioPath) {
  try {
    // ffprobe tr·∫£ v·ªÅ 1 d√≤ng duy nh·∫•t l√† s·ªë gi√¢y
    const out = execSync(
      `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${audioPath}"`
    )
      .toString()
      .trim();

    const seconds = parseFloat(out);
    return Number.isFinite(seconds) && seconds > 0 ? seconds : 0;
  } catch (err) {
    console.error('‚ö†Ô∏è  ffprobe error:', err.message);
    return 0; // ƒê·ªÉ code ph√≠a d∆∞·ªõi t·ª± b·ªè qua ph·∫ßn audio l·ªói
  }
}

// Chuy·ªÉn ƒë·ªïi gi√¢y sang ƒë·ªãnh d·∫°ng SRT
function secondsToSrtTime(sec) {
  if (!Number.isFinite(sec) || sec < 0) sec = 0;
  const whole = Math.floor(sec);
  const ms = Math.round((sec - whole) * 1000).toString().padStart(3, '0');

  const h = String(Math.floor(whole / 3600)).padStart(2, '0');
  const m = String(Math.floor((whole % 3600) / 60)).padStart(2, '0');
  const s = String(whole % 60).padStart(2, '0');

  return `${h}:${m}:${s},${ms}`;
}


// Sinh file ph·ª• ƒë·ªÅ SRT cho c√°c ph·∫ßn script
function generateSrtFile(parts, srtPath) {
  let srt = '';
  let current = 0;
  let idx = 1;

  parts.forEach((part) => {
    const dur = part.audioPath ? getAudioDuration(part.audioPath) : 0;
    if (dur === 0) return;        // b·ªè ƒëo·∫°n l·ªói

    const start = secondsToSrtTime(current);
    const end   = secondsToSrtTime(current + dur);

    srt += `${idx}\n${start} --> ${end}\n${part.text}\n\n`;
    current += dur;
    idx++;
  });

  fs.writeFileSync(srtPath, srt.trim() + '\n', 'utf8');
  return idx - 1;                 // s·ªë caption ƒë√£ ghi
}

//T·∫°o video t·ª´ h√¨nh ·∫£nh v√† √¢m thanh s·ª≠ d·ª•ng FFmpeg

const ffprobe = require('fluent-ffmpeg');
async function renderZoomFrames(
  imagePath,
  outDir,
  zoomStart,
  zoomEnd,
  duration,
  fps = 30,
  targetWidth = 1920,
  targetHeight = 1080
) {
  const totalFrames = Math.floor(duration * fps);
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

  // ƒê·∫£m b·∫£o ·∫£nh g·ªëc c√≥ size ƒë·ªß l·ªõn tr∆∞·ªõc khi zoom b·∫±ng c√°ch scale v·ªÅ t·ªâ l·ªá ph√π h·ª£p
  const getInitialScaleFactor = (imageWidth, imageHeight) => {
    const scaleW = targetWidth / imageWidth;
    const scaleH = targetHeight / imageHeight;
    return Math.max(scaleW, scaleH);
  };

  // L·∫•y k√≠ch th∆∞·ªõc ·∫£nh g·ªëc
  const probeImageSize = () => {
    const output = execSync(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 "${imagePath}"`).toString();
    const [w, h] = output.trim().split('x').map(Number);
    return { w, h };
  };

  const { w: imageWidth, h: imageHeight } = probeImageSize();
  const baseScale = getInitialScaleFactor(imageWidth, imageHeight);

  for (let i = 0; i < totalFrames; i++) {
    const t = i / totalFrames;
    const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // easeInOutQuad
    const zoom = zoomStart + (zoomEnd - zoomStart) * eased;

    // scale t·ªïng: ƒë·∫£m b·∫£o ·∫£nh ƒë·ªß l·ªõn r·ªìi m·ªõi zoom
    const scaleFactor = baseScale * zoom;

    const vf = `scale=iw*${scaleFactor}:ih*${scaleFactor},` +
      `crop=${targetWidth}:${targetHeight}:(iw-${targetWidth})/2:(ih-${targetHeight})/2`;

        const framePath = path.join(
      outDir,
      `frame_${i.toString().padStart(4, '0')}.jpg`
    );

    /* v·∫Ω 1 frame jpg duy nh·∫•t */
    execSync(
      `ffmpeg -y -i "${imagePath}" -vf "${vf}" -frames:v 1 "${framePath}"`,
      { stdio: 'pipe' }
    );
  }
}
async function createVideoSegment(
  imagePath,
  audioPath,
  outputPath,
  zoomStart = 1.0,
  zoomEnd   = 1.15,         // zoom nh·∫π ƒë·ªÉ tr√°nh v·ª° h√¨nh
  aspectRatio = '16:9'
) {
  /* x√°c ƒë·ªãnh k√≠ch th∆∞·ªõc ƒë√≠ch */
  const sizeMap = {
    '16:9': [1920, 1080],
    '9:16': [1080, 1920],
    '1:1' : [1080, 1080],
    '4:3' : [1440, 1080]
  };
  const [W, H] = sizeMap[aspectRatio] || sizeMap['16:9'];
  const fps = 30;

  /* l·∫•y th·ªùi l∆∞·ª£ng audio */
  let duration = await new Promise((resolve) => {
  ffprobe.ffprobe(audioPath, (e, m) =>
    resolve(
      m?.format?.duration && Number.isFinite(m.format.duration)
        ? m.format.duration
        : NaN
    )
  );
});

  if (!Number.isFinite(duration) || duration <= 0) {
  console.warn('‚ö†Ô∏è  Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c duration, d√πng m·∫∑c ƒë·ªãnh 10s');
  duration = 10;                       // fallback an to√†n
}
else {
  duration = Math.min(duration, 600);   //  h·∫°n ch·∫ø ‚â§10 ph√∫t
}
const totalFrames = fps * duration;
const zoomInc =
  totalFrames > 0 ? (zoomEnd - zoomStart) / totalFrames : 0.001; // lu√¥n h·ªØu h·∫°n

/* ---------- 2. filter & c√¢u l·ªánh ffmpeg ---------- */
const scalePad =
  `scale=${W}:${H}:force_original_aspect_ratio=decrease,` +
  `pad=${W}:${H}:(ow-iw)/2:(oh-ih)/2`;
const zoompan =
  `zoompan=z='zoom+${zoomInc}':d=1:` +
  `x='(iw-iw/zoom)/2':y='(ih-ih/zoom)/2':fps=${fps}`;
const vf = `${scalePad},${zoompan}`;

/* th√™m -t CH·ªà khi ta c√≥ duration h·ª£p l·ªá (>0)                     */
const tFlag = Number.isFinite(duration) && duration > 0 ? `-t ${duration}` : '';

const cmd =
  `ffmpeg -y -loop 1 -i "${imagePath}" -i "${audioPath}" ` +
  `-vf "${vf}" ${tFlag} -c:v libx264 -pix_fmt yuv420p ` +
  `-c:a aac -shortest "${outputPath}"`;
execSync(cmd, { stdio: 'inherit' });
}
/**
 * T·ª´ m·∫£ng scriptParts (ƒë√£ c√≥ imagePath, audioPath, text)
 * ‚Üí render t·ª´ng segment zoom-pan, gh√©p ch√∫ng, ch√®n ph·ª• ƒë·ªÅ,
 *   th√™m nh·∫°c n·ªÅn (n·∫øu c√≥)  r·ªìi tr·∫£ v·ªÅ ƒë∆∞·ªùng d·∫´n video cu·ªëi.
 */
async function createVideoWithAudio(
  scriptParts,             // [{imagePath,audioPath,text}, ‚Ä¶]
  outputPath,              // ‚Ä¶/public/videos/advanced_video_xxx.mp4
  aspectRatio = '16:9',    // 16:9 | 9:16 | ‚Ä¶
  bgMusic     = null,      // ƒë∆∞·ªùng d·∫´n t·ªõi nh·∫°c n·ªÅn (tu·ª≥ ch·ªçn)
  bgVolume    = 0.25,      // 0 ‚Äì 1
  musicStart  = 0,
  musicEnd    = null
) {
  /* -------------------------------------------------- */
  /* 0. Chu·∫©n b·ªã                                       */
  /* -------------------------------------------------- */
  const outDir = path.dirname(outputPath);
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

  const size = { '16:9':[1920,1080],'9:16':[1080,1920],'1:1':[1080,1080],'4:3':[1440,1080] }[aspectRatio] || [1920,1080];
  const [vw, vh] = size;
  const fps = 30;

  /* -------------------------------------------------- */
  /* 1. Render SEGMENT                                  */
  /* -------------------------------------------------- */
  const segments = [];
  let timeline   = 0;            // t√≠nh th·ªùi gian ƒë·ªÉ ghi ph·ª• ƒë·ªÅ
  const srtLines = [];

  for (let i = 0; i < scriptParts.length; i++) {
   const p = scriptParts[i];
   if (!p.imagePath || !p.audioPath) continue;

    /* chuy·ªÉn v·ªÅ path tuy·ªát ƒë·ªëi tr∆∞·ªõc khi d√πng ffmpeg */
    const imgAbs = convertUrlToFilePath(p.imagePath);
    const audAbs = convertUrlToFilePath(p.audioPath);       // b·ªè qua part thi·∫øu media

    /* 1.1  X√°c ƒë·ªãnh th·ªùi l∆∞·ª£ng audio  ----------------- */
    let duration = await new Promise(r => {
      ffprobe.ffprobe(p.audioPath, (e,md)=> r(!e && md?.format?.duration || 0));
    });
    if (!Number.isFinite(duration) || duration <= 0) {
      console.warn('‚ö†Ô∏è  Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c duration, d√πng m·∫∑c ƒë·ªãnh 10s');
      duration = 10;
    }

    /* 1.2  Render frame zoom-pan ---------------------- */
    const frameDir = path.join(outDir, `frames_${Date.now()}_${i}`);
    fs.mkdirSync(frameDir, { recursive:true });

    const zoomStart = i % 2 ? 1.5 : 1.0;
    const zoomEnd   = i % 2 ? 1.0 : 1.5;
    await renderZoomFrames(
   imgAbs,      frameDir, zoomStart, zoomEnd,
    duration, fps, vw, vh
 );
    /* 1.3  G·ªôp frame + audio th√†nh segment ------------ */
   const segPath = path.join(outDir, `segment_${i}_${Date.now()}.mp4`);
 execSync(
   `ffmpeg -y -framerate ${fps} -i "${frameDir}/frame_%04d.jpg" ` +
   `-i "${audAbs}" -c:v libx264 -pix_fmt yuv420p -c:a aac -shortest "${segPath}"`,
   { stdio:'inherit' }
 );
    segments.push(segPath);

    /* 1.4  Ph·ª• ƒë·ªÅ d√≤ng hi·ªán t·∫°i ----------------------- */
    const ts = s => {
      const h=String(Math.floor(s/3600)).padStart(2,'0');
      const m=String(Math.floor(s%3600/60)).padStart(2,'0');
      const ss=String(Math.floor(s%60)).padStart(2,'0');
      const ms=String(Math.round((s%1)*1000)).padStart(3,'0');
      return `${h}:${m}:${ss},${ms}`;
    };
    srtLines.push(
      `${srtLines.length+1}`,
      `${ts(timeline)} --> ${ts(timeline+duration)}`,
      (p.text||'').trim(), ''
    );
    timeline += duration;

    fs.rmSync(frameDir,{recursive:true,force:true});
  }

  if (!segments.length) throw new Error('Kh√¥ng c√≤n segment h·ª£p l·ªá');

  /* -------------------------------------------------- */
  /* 2. CONCAT t·∫•t c·∫£ segment ------------------------- */
  const concatTxt = path.join(outDir,'concat.txt');
  fs.writeFileSync(concatTxt, segments.map(f=>`file '${path.basename(f)}'`).join('\n'));

  const concatMp4 = path.join(outDir,`concat_${Date.now()}.mp4`);
  execSync(
    `ffmpeg -y -f concat -safe 0 -i "${path.basename(concatTxt)}" -c copy "${path.basename(concatMp4)}"`,
    { cwd: outDir, stdio:'inherit' }
  );

  /* d·ªçn file segment t·∫°m */
  segments.forEach(f=>fs.unlinkSync(f));
  fs.unlinkSync(concatTxt);

  /* -------------------------------------------------- */
  /* 3. Ch√®n ph·ª• ƒë·ªÅ v·ªõi ƒë∆∞·ªùng d·∫´n T∆Ø∆†NG ƒê·ªêI ----------- */
  const srtFile = path.join(outDir,`sub_${Date.now()}.srt`);
  fs.writeFileSync(srtFile, srtLines.join('\n'),'utf8');

  const withSubs = path.join(outDir,`with_subs_${Date.now()}.mp4`);
  execSync(
    `ffmpeg -y -i "${path.basename(concatMp4)}" ` +
    `-vf "subtitles=${path.basename(srtFile)}" -c:a copy "${path.basename(withSubs)}"`,
    { cwd: outDir, stdio:'inherit' }
  );

  fs.unlinkSync(srtFile);
  fs.unlinkSync(concatMp4);

  /* -------------------------------------------------- */
  /* 4. Nh·∫°c n·ªÅn (n·∫øu c√≥) ------------------------------ */
  let finalOut = withSubs;
  if (bgMusic) {
    const mixed = path.join(outDir,`with_music_${Date.now()}.mp4`);
    const vol   = Number(bgVolume) || 0.25;
    const trim  = musicEnd !== null ? `-to ${musicEnd}` : '';
    execSync(
      `ffmpeg -y -i "${finalOut}" ` +
      `-ss ${musicStart} ${trim} -i "${bgMusic}" ` +
      `-filter_complex "[1:a]volume=${vol}[bg];[0:a][bg]amix=inputs=2:duration=first[a]" ` +
      `-map 0:v -map "[a]" -c:v copy -shortest "${mixed}"`,
      { stdio:'inherit' }
    );
    fs.unlinkSync(finalOut);
    finalOut = mixed;
  }

  /* -------------------------------------------------- */
  /* 5. Tr·∫£ v·ªÅ                                         */
  fs.renameSync(finalOut, outputPath);
  console.log(`‚úÖ  Video cu·ªëi: ${outputPath}`);
  return outputPath;
}

/**
 * API ch√≠nh: T·∫°o video t·ª´ k·ªãch b·∫£n v·ªõi gi·ªçng ƒë·ªçc
 */
const generateAdvancedVideo = async (req, res) => {
  console.log('üöÄ B·∫Øt ƒë·∫ßu t·∫°o video n√¢ng cao...');
  console.log('Body request:', JSON.stringify(req.body).substring(0, 200) + '...');

  const { topic, script, voiceId } = req.body;

  if (!topic && !script) {
    console.log('‚ùå L·ªói: Thi·∫øu ch·ªß ƒë·ªÅ ho·∫∑c k·ªãch b·∫£n');
    return res.status(400).json({ success: false, error: 'Vui l√≤ng cung c·∫•p ch·ªß ƒë·ªÅ ho·∫∑c k·ªãch b·∫£n!' });
  }

  try {
    // T·∫°o th∆∞ m·ª•c ƒë·∫ßu ra n·∫øu ch∆∞a t·ªìn t·∫°i
    const outputDir = path.join(__dirname, '../../public/videos');
    const tempDir = path.join(__dirname, '../../public/temp');
    const audioDir = path.join(tempDir, 'audio');

    [outputDir, tempDir, audioDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        console.log(`üìÅ T·∫°o th∆∞ m·ª•c: ${dir}`);
        fs.mkdirSync(dir, { recursive: true });
      }
    });

    // Ki·ªÉm tra FFmpeg
    try {
      console.log('üîç Ki·ªÉm tra FFmpeg...');
      const ffmpegVersion = execSync('ffmpeg -version').toString().split('\n')[0];
      console.log(`‚úÖ FFmpeg: ${ffmpegVersion}`);
    } catch (error) {
      console.error('‚ùå L·ªói FFmpeg:', error.message);
      throw new Error('C·∫ßn c√†i ƒë·∫∑t FFmpeg ƒë·ªÉ t·∫°o video. H√£y c√†i ƒë·∫∑t FFmpeg v√† kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng.');
    }

    // T·∫°o k·ªãch b·∫£n n·∫øu ch∆∞a c√≥, v√† chu·∫©n h√≥a k·ªãch b·∫£n n·∫øu c√≥
    let finalScript = script;

    if (!script || script.trim() === '') {
      console.log('ü§ñ T·∫°o k·ªãch b·∫£n t·ª´ ch·ªß ƒë·ªÅ:', topic);
      try {
        const generatedScript = await generateScriptByVertexAI(topic);
        finalScript = generatedScript;
        console.log('‚úÖ ƒê√£ t·∫°o k·ªãch b·∫£n t·ª´ AI');
      } catch (error) {
        console.error('‚ùå L·ªói khi t·∫°o k·ªãch b·∫£n t·ª´ AI:', error);
        throw new Error(`Kh√¥ng th·ªÉ t·∫°o k·ªãch b·∫£n t·ª´ ch·ªß ƒë·ªÅ: ${error.message}`);
      }
    } else {
      // Chu·∫©n h√≥a k·ªãch b·∫£n ƒë√£ c√≥
      console.log('üìù Chu·∫©n h√≥a k·ªãch b·∫£n ƒë√£ c√≥...');

      // Ki·ªÉm tra n·∫øu k·ªãch b·∫£n kh√¥ng ph·∫£i l√† k·ªãch b·∫£n th·ª±c, m√† l√† danh s√°ch ƒë·ªÅ xu·∫•t
      if (finalScript.includes('H√£y nh·∫•n v√†o 1 ch·ªß ƒë·ªÅ ƒë·ªÉ t·∫°o k·ªãch b·∫£n')) {
        console.error('‚ùå N·ªôi dung kh√¥ng ph·∫£i l√† k·ªãch b·∫£n m√† l√† danh s√°ch ƒë·ªÅ xu·∫•t');
        throw new Error('N·ªôi dung kh√¥ng ph·∫£i l√† k·ªãch b·∫£n. Vui l√≤ng t·∫°o k·ªãch b·∫£n tr∆∞·ªõc khi t·∫°o video.');
      }
    }

    console.log('üìú K·ªãch b·∫£n cu·ªëi c√πng (ƒëo·∫°n ƒë·∫ßu):', finalScript.substring(0, 200) + '...');

    // Ph√¢n t√≠ch k·ªãch b·∫£n
    console.log('üîç Ph√¢n t√≠ch k·ªãch b·∫£n...');
    const scriptParts = extractScriptParts(finalScript);
    console.log(`‚úÖ Ph√¢n t√≠ch ƒë∆∞·ª£c ${scriptParts.length} ph·∫ßn k·ªãch b·∫£n`);

    if (scriptParts.length === 0) {
      console.error('‚ùå Kh√¥ng t√¨m th·∫•y ph·∫ßn n√†o trong k·ªãch b·∫£n');
      const errorMessage = 'K·ªãch b·∫£n kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng. H√£y ki·ªÉm tra l·∫°i. ' +
        'K·ªãch b·∫£n ph·∫£i c√≥ c√°c ph·∫ßn ƒë∆∞·ª£c ƒë√°nh d·∫•u b·∫±ng "## PH·∫¶N" v√† c√≥ "**L·ªùi tho·∫°i:**" v√† "**H√¨nh ·∫£nh:**".';
      throw new Error(errorMessage);
    }

    // T·∫°o file √¢m thanh cho t·ª´ng ph·∫ßn
    console.log('üîä T·∫°o √¢m thanh cho k·ªãch b·∫£n...');
    const scriptPartsWithAudio = await createAudioForScript(finalScript, audioDir, voiceId);
    console.log(`‚úÖ ƒê√£ t·∫°o ${scriptPartsWithAudio.length} file √¢m thanh`);

    if (scriptPartsWithAudio.length === 0) {
      console.error('‚ùå Kh√¥ng t·∫°o ƒë∆∞·ª£c file √¢m thanh n√†o');
      throw new Error('Kh√¥ng th·ªÉ t·∫°o √¢m thanh. H√£y ki·ªÉm tra file credentials Google Cloud.');
    }

    // T·∫£i h√¨nh ·∫£nh cho t·ª´ng ph·∫ßn
    console.log('üñºÔ∏è T·∫£i h√¨nh ·∫£nh cho k·ªãch b·∫£n...');
    const scriptPartsWithMedia = await downloadImagesForScriptParts(scriptPartsWithAudio, tempDir);
    console.log(`‚úÖ ƒê√£ t·∫£i ${scriptPartsWithMedia.filter(p => p.imagePath).length} h√¨nh ·∫£nh`);

    if (scriptPartsWithMedia.filter(p => p.imagePath).length === 0) {
      console.error('‚ùå Kh√¥ng t·∫£i ƒë∆∞·ª£c h√¨nh ·∫£nh n√†o');
      throw new Error('Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh. H√£y ki·ªÉm tra k·∫øt n·ªëi m·∫°ng.');
    }

    // T·∫°o t√™n file video
    const videoFileName = `advanced_video_${Date.now()}.mp4`;
    const outputPath = path.join(outputDir, videoFileName);

    // T·∫°o video
    console.log('üé¨ B·∫Øt ƒë·∫ßu t·∫°o video...');
    const finalVideoPath = await createVideoWithAudio(
      scriptPartsWithMedia,
      outputPath,
      '16:9',              // aspectRatio m·∫∑c ƒë·ªãnh
      music,
      musicVolume,
      musicStartTime,
      musicEndTime
    );


    console.log('‚úÖ ƒê√£ t·∫°o video th√†nh c√¥ng:', outputPath);

    // Tr·∫£ v·ªÅ k·∫øt qu·∫£
    return res.json({
      success: true,
      videoUrl: `/outputs/${path.basename(finalVideoPath)}`
    });

  } catch (error) {
    console.error('‚ùå L·ªñI NGHI√äM TR·ªåNG:', error);
    console.error('Chi ti·∫øt l·ªói:', error.stack);

    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫°o video',
      stack: error.stack
    });
  }
};

// Danh s√°ch c√°c gi·ªçng ƒë·ªçc ti·∫øng Vi·ªát c√≥ s·∫µn
const getAvailableVoices = async (req, res) => {
  try {
    const voices = Object.entries(VIETNAMESE_VOICES).map(([key, value]) => ({
      id: value,
      name: key,
      gender: key.includes('FEMALE') ? 'N·ªØ' : 'Nam',
      quality: key.includes('NEURAL') ? 'Cao nh·∫•t' : (key.includes('WAVENET') ? 'Cao' : 'Ti√™u chu·∫©n')
    }));

    return res.json({
      success: true,
      voices
    });
  } catch (error) {
    console.error('L·ªói khi l·∫•y danh s√°ch gi·ªçng ƒë·ªçc:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói khi l·∫•y danh s√°ch gi·ªçng ƒë·ªçc'
    });
  }
};

/**
 * API chu·∫©n b·ªã k·ªãch b·∫£n v√† ph√¢n t√≠ch th√†nh c√°c ph·∫ßn ƒë·ªÉ ch·ªânh s·ª≠a
 */
const prepareVideoScript = async (req, res) => {
  console.log('üöÄ B·∫Øt ƒë·∫ßu chu·∫©n b·ªã k·ªãch b·∫£n...');
  console.log('Body request:', JSON.stringify(req.body).substring(0, 200) + '...');

  const { topic, script, voiceId, aspectRatio = '16:9', imageModel = 'ultra' } = req.body;

  if (!topic && !script) {
    console.log('‚ùå L·ªói: Thi·∫øu ch·ªß ƒë·ªÅ ho·∫∑c k·ªãch b·∫£n');
    return res.status(400).json({ success: false, error: 'Vui l√≤ng cung c·∫•p ch·ªß ƒë·ªÅ ho·∫∑c k·ªãch b·∫£n!' });
  }

  try {
    // T·∫°o th∆∞ m·ª•c ƒë·∫ßu ra n·∫øu ch∆∞a t·ªìn t·∫°i
    const tempDir = path.join(__dirname, '../../public/temp');
    const audioDir = path.join(tempDir, 'audio');

    [tempDir, audioDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        console.log(`üìÅ T·∫°o th∆∞ m·ª•c: ${dir}`);
        fs.mkdirSync(dir, { recursive: true });
      }
    });

    // Ki·ªÉm tra FFmpeg
    try {
      console.log('üîç Ki·ªÉm tra FFmpeg...');
      const ffmpegVersion = execSync('ffmpeg -version').toString().split('\n')[0];
      console.log(`‚úÖ FFmpeg: ${ffmpegVersion}`);
    } catch (error) {
      console.error('‚ùå L·ªói FFmpeg:', error.message);
      throw new Error('C·∫ßn c√†i ƒë·∫∑t FFmpeg ƒë·ªÉ t·∫°o video. H√£y c√†i ƒë·∫∑t FFmpeg v√† kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng.');
    }

    // T·∫°o k·ªãch b·∫£n n·∫øu ch∆∞a c√≥, v√† chu·∫©n h√≥a k·ªãch b·∫£n n·∫øu c√≥
    let finalScript = script;

    if (!script || script.trim() === '') {
      console.log('ü§ñ T·∫°o k·ªãch b·∫£n t·ª´ ch·ªß ƒë·ªÅ:', topic);
      try {
        const generatedScript = await generateScriptByVertexAI(topic);
        finalScript = generatedScript;
        console.log('‚úÖ ƒê√£ t·∫°o k·ªãch b·∫£n t·ª´ AI');
      } catch (error) {
        console.error('‚ùå L·ªói khi t·∫°o k·ªãch b·∫£n t·ª´ AI:', error);
        throw new Error(`Kh√¥ng th·ªÉ t·∫°o k·ªãch b·∫£n t·ª´ ch·ªß ƒë·ªÅ: ${error.message}`);
      }
    } else {
      // Chu·∫©n h√≥a k·ªãch b·∫£n ƒë√£ c√≥
      console.log('üìù Chu·∫©n h√≥a k·ªãch b·∫£n ƒë√£ c√≥...');

      // Ki·ªÉm tra n·∫øu k·ªãch b·∫£n kh√¥ng ph·∫£i l√† k·ªãch b·∫£n th·ª±c, m√† l√† danh s√°ch ƒë·ªÅ xu·∫•t
      if (finalScript.includes('H√£y nh·∫•n v√†o 1 ch·ªß ƒë·ªÅ ƒë·ªÉ t·∫°o k·ªãch b·∫£n')) {
        console.error('‚ùå N·ªôi dung kh√¥ng ph·∫£i l√† k·ªãch b·∫£n m√† l√† danh s√°ch ƒë·ªÅ xu·∫•t');
        throw new Error('N·ªôi dung kh√¥ng ph·∫£i l√† k·ªãch b·∫£n. Vui l√≤ng t·∫°o k·ªãch b·∫£n tr∆∞·ªõc khi t·∫°o video.');
      }
    }

    console.log('üìú K·ªãch b·∫£n cu·ªëi c√πng (ƒëo·∫°n ƒë·∫ßu):', finalScript.substring(0, 200) + '...');

    // Ph√¢n t√≠ch k·ªãch b·∫£n
    console.log('üîç Ph√¢n t√≠ch k·ªãch b·∫£n...');
    const scriptParts = extractScriptParts(finalScript);
    console.log(`‚úÖ Ph√¢n t√≠ch ƒë∆∞·ª£c ${scriptParts.length} ph·∫ßn k·ªãch b·∫£n`);

    if (scriptParts.length === 0) {
      console.error('‚ùå Kh√¥ng t√¨m th·∫•y ph·∫ßn n√†o trong k·ªãch b·∫£n');
      const errorMessage = 'K·ªãch b·∫£n kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng. H√£y ki·ªÉm tra l·∫°i. ' +
        'K·ªãch b·∫£n ph·∫£i c√≥ c√°c ph·∫ßn ƒë∆∞·ª£c ƒë√°nh d·∫•u b·∫±ng "## PH·∫¶N" v√† c√≥ "**L·ªùi tho·∫°i:**" v√† "**H√¨nh ·∫£nh:**".';
      throw new Error(errorMessage);
    }

    // T·∫°o ID phi√™n l√†m vi·ªác ƒë·ªÉ theo d√µi
    const sessionId = Date.now().toString();

    // L∆∞u k·ªãch b·∫£n v√† c√°c ph·∫ßn v√†o session ƒë·ªÉ s·ª≠ d·ª•ng sau
    if (!req.session) {
      req.session = {};
    }

    req.session.videoPreparation = {
      sessionId,
      script: finalScript,
      topic: topic || null,
      scriptParts: scriptParts.map((part, index) => ({
        id: `part_${index}`,
        index: index,
        ...part,
        audioPath: null,
        imagePath: null
      })),
      voiceId,
      aspectRatio,
      imageModel // Th√™m th√¥ng tin v·ªÅ m√¥ h√¨nh AI t·∫°o ·∫£nh
    };

    // Tr·∫£ v·ªÅ th√¥ng tin k·ªãch b·∫£n ƒë√£ ph√¢n t√≠ch
    return res.json({
      success: true,
      sessionId,
      scriptParts: scriptParts.map((part, index) => ({
        id: `part_${index}`,
        index: index,
        ...part
      })),
      voiceId,
      aspectRatio,
      imageModel, // Th√™m th√¥ng tin v·ªÅ m√¥ h√¨nh AI t·∫°o ·∫£nh
      script: finalScript
    });
  } catch (error) {
    console.error('‚ùå L·ªñI:', error);

    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi chu·∫©n b·ªã k·ªãch b·∫£n',
      stack: error.stack
    });
  }
};
async function addMusicToVideo(inputVideoPath, outputVideoPath, music, musicVolume, musicStartTime, musicEndTime, outputDir) {
  try {
    const musicPath = path.join(__dirname, '../../public/music', music);
    if (!fs.existsSync(musicPath)) {
      throw new Error(`File nh·∫°c kh√¥ng t·ªìn t·∫°i: ${musicPath}`);
    }
    const clippedMusicPath = path.join(outputDir, `clip_${Date.now()}.mp3`);
    const finalOutputWithMusic = path.join(outputDir, `output_final_${Date.now()}.mp4`);
    const trimCmd = `ffmpeg -y -i "${musicPath}" -ss ${musicStartTime} ${musicEndTime ? `-to ${musicEndTime}` : ''} -c copy "${clippedMusicPath}"`;
    execSync(trimCmd, { stdio: 'inherit' });
    const mixCmd = `ffmpeg -y -i "${inputVideoPath}" -i "${clippedMusicPath}" -filter_complex "[1:a]volume=${musicVolume}[a1];[0:a][a1]amix=inputs=2:duration=first[aout]" -map 0:v -map "[aout]" -c:v copy -shortest "${finalOutputWithMusic}"`;
    execSync(mixCmd, { stdio: 'inherit' });
    fs.copyFileSync(finalOutputWithMusic, outputVideoPath);
    [clippedMusicPath, finalOutputWithMusic].forEach(file => {
      if (fs.existsSync(file)) fs.unlinkSync(file);
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi th√™m nh·∫°c n·ªÅn:', error.message);
    throw error;
  }
}

/**
 * API t·∫°o/t·∫°o l·∫°i h√¨nh ·∫£nh cho m·ªôt ph·∫ßn c·ª• th·ªÉ
 */
const generateImageForPart = async (req, res) => {
  console.log('üñºÔ∏è B·∫Øt ƒë·∫ßu t·∫°o h√¨nh ·∫£nh cho ph·∫ßn...');

  const { sessionId, partId, customPrompt } = req.body;

  if (!sessionId || !partId) {
    return res.status(400).json({
      success: false,
      error: 'Thi·∫øu th√¥ng tin phi√™n l√†m vi·ªác ho·∫∑c ID ph·∫ßn'
    });
  }

  try {
    // Ki·ªÉm tra phi√™n l√†m vi·ªác
    if (!req.session || !req.session.videoPreparation || req.session.videoPreparation.sessionId !== sessionId) {
      throw new Error('Phi√™n l√†m vi·ªác kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
    }

    // L·∫•y th√¥ng tin t·ªâ l·ªá khung h√¨nh t·ª´ session
    const aspectRatio = req.session.videoPreparation.aspectRatio || '16:9';
    // L·∫•y th√¥ng tin m√¥ h√¨nh AI t·∫°o ·∫£nh t·ª´ session
    const imageModel = req.session.videoPreparation.imageModel || 'ultra';

    // T√¨m ph·∫ßn c·∫ßn t·∫°o h√¨nh ·∫£nh
    const part = req.session.videoPreparation.scriptParts.find(p => p.id === partId);

    if (!part) {
      throw new Error(`Kh√¥ng t√¨m th·∫•y ph·∫ßn v·ªõi ID: ${partId}`);
    }

    // X√°c ƒë·ªãnh prompt cho h√¨nh ·∫£nh
    let imagePrompt = customPrompt;

    // N·∫øu kh√¥ng c√≥ prompt t√πy ch·ªânh, s·ª≠ d·ª•ng to√†n b·ªô m√¥ t·∫£ h√¨nh ·∫£nh ho·∫∑c tr√≠ch xu·∫•t t·ª´ vƒÉn b·∫£n
    if (!imagePrompt) {
      if (part.image && part.image.trim() !== '') {
        // S·ª≠ d·ª•ng to√†n b·ªô m√¥ t·∫£ h√¨nh ·∫£nh thay v√¨ ch·ªâ tr√≠ch xu·∫•t t·ª´ kh√≥a
        imagePrompt = part.image.trim();
        console.log(`üñºÔ∏è S·ª≠ d·ª•ng to√†n b·ªô m√¥ t·∫£ h√¨nh ·∫£nh: ${imagePrompt}`);
      } else {
        // Tr√≠ch xu·∫•t t·ª´ kh√≥a t·ª´ vƒÉn b·∫£n
        const textKeywords = part.text
          .split(/\s+/)
          .filter(word => word.length > 4)
          .filter(word => !['nh∆∞', 'nh∆∞ng', 'ho·∫∑c', 'nh·ªØng', 'ƒë∆∞·ª£c', 'trong', 'c√πng'].includes(word.toLowerCase()))
          .slice(0, 3);

        imagePrompt = textKeywords.join(', ');
      }
    }

    // S·ª≠ d·ª•ng prompt g·ªëc v√† th√™m m·ªôt s·ªë h∆∞·ªõng d·∫´n c∆° b·∫£n
    const enhancedPrompt = `${imagePrompt}, ch·∫•t l∆∞·ª£ng cao, chi ti·∫øt r√µ n√©t, kh√¥ng c√≥ ch·ªØ hay watermark`;

    console.log(`üñºÔ∏è T·∫°o h√¨nh ·∫£nh v·ªõi prompt: ${enhancedPrompt}`);
    console.log(`üìê T·ªâ l·ªá khung h√¨nh: ${aspectRatio}`);

    // T·∫°o th∆∞ m·ª•c t·∫°m n·∫øu ch∆∞a c√≥
    const tempDir = path.join(__dirname, '../../public/temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }

    // T·∫°o h√¨nh ·∫£nh b·∫±ng API
    const response = await axios.post('http://localhost:3000/api/image/generate', {
      prompt: enhancedPrompt,
      modelType: imageModel, // S·ª≠ d·ª•ng m√¥ h√¨nh AI ƒë√£ ch·ªçn
      imageCount: 1,
      aspectRatio: aspectRatio,
      retryDelay: 30000, // Th√™m th·ªùi gian ch·ªù 30 gi√¢y
      maxRetries: 5      // Th·ª≠ t·ªëi ƒëa 5 l·∫ßn
    });

    if (response.data.success && response.data.images && response.data.images.length > 0) {
      // L∆∞u ·∫£nh v√†o th∆∞ m·ª•c t·∫°m
      const imageFilename = `part_${part.index}_${Date.now()}.jpg`;
      const filePath = path.join(tempDir, imageFilename);

      if (response.data.images[0].type === 'base64') {
        fs.writeFileSync(filePath, Buffer.from(response.data.images[0].imageData, 'base64'));
      } else if (response.data.images[0].type === 'url') {
        const imgResponse = await axios.get(response.data.images[0].imageData, { responseType: 'arraybuffer' });
        fs.writeFileSync(filePath, Buffer.from(imgResponse.data));
      }

      // C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n h√¨nh ·∫£nh trong session
      part.imagePath = filePath;

      return res.json({
        success: true,
        imagePath: `/temp/${imageFilename}`,
        prompt: enhancedPrompt
      });
    } else {
      throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c h√¨nh ·∫£nh t·ª´ API t·∫°o ·∫£nh');
    }
  } catch (error) {
    console.error('‚ùå L·ªói khi t·∫°o h√¨nh ·∫£nh:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫°o h√¨nh ·∫£nh'
    });
  }
};

/**
 * API t·∫°o/t·∫°o l·∫°i gi·ªçng ƒë·ªçc cho m·ªôt ph·∫ßn c·ª• th·ªÉ
 */
const generateAudioForPart = async (req, res) => {
  console.log('üîä B·∫Øt ƒë·∫ßu t·∫°o gi·ªçng ƒë·ªçc cho ph·∫ßn...');

  const { sessionId, partId, voiceId, customText } = req.body;

  if (!sessionId || !partId) {
    return res.status(400).json({
      success: false,
      error: 'Thi·∫øu th√¥ng tin phi√™n l√†m vi·ªác ho·∫∑c ID ph·∫ßn'
    });
  }

  try {
    // Ki·ªÉm tra phi√™n l√†m vi·ªác
    if (!req.session || !req.session.videoPreparation || req.session.videoPreparation.sessionId !== sessionId) {
      throw new Error('Phi√™n l√†m vi·ªác kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
    }

    // T√¨m ph·∫ßn c·∫ßn t·∫°o gi·ªçng ƒë·ªçc
    const part = req.session.videoPreparation.scriptParts.find(p => p.id === partId);

    if (!part) {
      throw new Error(`Kh√¥ng t√¨m th·∫•y ph·∫ßn v·ªõi ID: ${partId}`);
    }

    // X√°c ƒë·ªãnh vƒÉn b·∫£n v√† gi·ªçng ƒë·ªçc
    const text = customText || part.text;
    const selectedVoiceId = voiceId || req.session.videoPreparation.voiceId || VIETNAMESE_VOICES.FEMALE_NEURAL_A;

    // T·∫°o th∆∞ m·ª•c l∆∞u tr·ªØ
    const audioDir = path.join(__dirname, '../../public/temp/audio');
    if (!fs.existsSync(audioDir)) {
      fs.mkdirSync(audioDir, { recursive: true });
    }

    // ƒê∆∞·ªùng d·∫´n file ƒë·∫ßu ra
    const audioFilename = `part_${part.index}_${Date.now()}.mp3`;
    const outputPath = path.join(audioDir, audioFilename);

    // T·∫°o gi·ªçng ƒë·ªçc
    await convertTextToSpeech(text, outputPath, selectedVoiceId);

    // C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n √¢m thanh trong session
    const rel = `/temp/audio/${audioFilename}`;
 part.audioPath = rel;

    // N·∫øu vƒÉn b·∫£n ƒë∆∞·ª£c t√πy ch·ªânh, c·∫≠p nh·∫≠t n·ªôi dung text trong part
    if (customText) {
      part.text = customText;
    }

    return res.json({
      success: true,
      audioPath: `/temp/audio/${audioFilename}`,
      audioPath: rel,
      text: text
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi t·∫°o gi·ªçng ƒë·ªçc:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫°o gi·ªçng ƒë·ªçc'
    });
  }
};

/**
 * API ho√†n thi·ªán video t·ª´ c√°c ph·∫ßn ƒë√£ chu·∫©n b·ªã
 */
/**
 * API ho√†n thi·ªán video t·ª´ c√°c ph·∫ßn ƒë√£ chu·∫©n b·ªã
 */
const finalizeAdvancedVideo = async (req, res) => {
  console.log('üé¨ B·∫Øt ƒë·∫ßu ho√†n thi·ªán video...');

  const {
    sessionId,
    aspectRatio = '16:9',
    music = null,
    musicVolume = 0.3,
    musicStartTime = 0,
    musicEndTime = null
  } = req.body;

  if (!sessionId) {
    return res.status(400).json({ success: false, error: 'Thi·∫øu th√¥ng tin phi√™n l√†m vi·ªác' });
  }

  try {
    /* ------------------------------------------------
       1. L·∫•y d·ªØ li·ªáu phi√™n & ki·ªÉm tra
    -------------------------------------------------*/
    if (
      !req.session ||
      !req.session.videoPreparation ||
      req.session.videoPreparation.sessionId !== sessionId
    ) {
      throw new Error('Phi√™n l√†m vi·ªác kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
    }

    const { script, scriptParts, topic } = req.session.videoPreparation;
    const validParts = scriptParts.filter(p => p.imagePath && p.audioPath);
    if (!validParts.length) throw new Error('Kh√¥ng c√≥ ph·∫ßn n√†o c√≥ ƒë·ªß media');

    /* ------------------------------------------------
       2. Chu·∫©n b·ªã ƒë∆∞·ªùng d·∫´n xu·∫•t
    -------------------------------------------------*/
    const outputDir = path.join(__dirname, '../../public/videos');
    if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

    const videoFileName = `advanced_video_${sessionId}.mp4`;
    const outputPath = path.join(outputDir, videoFileName);

    /* ------------------------------------------------
       3. Render video (t·∫≠n d·ª•ng h√†m ƒë√£ vi·∫øt)
    -------------------------------------------------*/
    await createVideoWithAudio(
      validParts,
      outputPath,
      aspectRatio,
      music,
      musicVolume,
      musicStartTime,
      musicEndTime
    );


    /* ------------------------------------------------
       4. Upload Firebase & ghi DB
    -------------------------------------------------*/
    const firebaseKey = `videos/${videoFileName}`;
    const publicUrl = await uploadFile(
      outputPath,
      firebaseKey,
      { contentType: 'video/mp4' }   // gi√∫p tr√¨nh duy·ªát stream ngay
    );
    console.log('üöÄ ƒê√£ upload Firebase:', publicUrl);

    // (tu·ª≥ ch·ªçn) ghi v√†o b·∫£ng videos
    const stats = fs.statSync(outputPath);
    const sizeMb = (stats.size / 1024 / 1024).toFixed(2);
    console.log("ID nguoi dung: ", req.session.user)
    const userId =
      req.session?.user?.id_nguoidung
      || req.user?.id_nguoidung
      || null;

    await videoModel.insertVideo({
      filename: videoFileName,
      firebaseKey: firebaseKey,
      publicUrl: publicUrl,
      sizeMb: sizeMb,
      title: topic || 'Video ho√†n thi·ªán',
      script: script || null,
      userId
    });

    /* ------------------------------------------------
       5. Tr·∫£ k·∫øt qu·∫£
    -------------------------------------------------*/
    return res.json({
      success: true,
      videoUrl: publicUrl,                 // URL Firebase
      localPath: `/videos/${videoFileName}`, // n·∫øu b·∫°n mu·ªën tham chi·∫øu t·∫°m
      script: script
    });

  } catch (err) {
    console.error('‚ùå L·ªói khi ho√†n thi·ªán video:', err);
    return res.status(500).json({ success: false, error: err.message });
  }
};


/**
 * API t·∫£i l√™n h√¨nh ·∫£nh t√πy ch·ªânh cho m·ªôt ph·∫ßn c·ª• th·ªÉ
 * L∆∞u √Ω: H√†m n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ x·ª≠ l√Ω t·ª´ng request v·ªõi middleware upload.single('image')
 */
const uploadImageForPart = async (req, res) => {
  // req.file ƒë∆∞·ª£c thi·∫øt l·∫≠p b·ªüi multer sau khi t·∫£i l√™n th√†nh c√¥ng
  if (!req.file) {
    return res.status(400).json({
      success: false,
      error: 'Kh√¥ng t√¨m th·∫•y file ·∫£nh trong request'
    });
  }

  const { sessionId, partId } = req.body;

  if (!sessionId || !partId) {
    // X√≥a file ƒë√£ t·∫£i l√™n n·∫øu th√¥ng tin kh√¥ng h·ª£p l·ªá
    if (req.file.path && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    return res.status(400).json({
      success: false,
      error: 'Thi·∫øu th√¥ng tin phi√™n l√†m vi·ªác ho·∫∑c ID ph·∫ßn'
    });
  }

  try {
    // Ki·ªÉm tra phi√™n l√†m vi·ªác
    if (!req.session || !req.session.videoPreparation || req.session.videoPreparation.sessionId !== sessionId) {
      throw new Error('Phi√™n l√†m vi·ªác kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');
    }

    // T√¨m ph·∫ßn c·∫ßn c·∫≠p nh·∫≠t h√¨nh ·∫£nh
    const part = req.session.videoPreparation.scriptParts.find(p => p.id === partId);

    if (!part) {
      throw new Error(`Kh√¥ng t√¨m th·∫•y ph·∫ßn v·ªõi ID: ${partId}`);
    }

    // C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n h√¨nh ·∫£nh trong session
    part.imagePath = req.file.path;

    // Tr·∫£ v·ªÅ ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi ƒë·ªÉ hi·ªÉn th·ªã trong frontend
    const relativePath = `/temp/${path.basename(req.file.path)}`;

    return res.json({
      success: true,
      imagePath: relativePath,
      filename: path.basename(req.file.path)
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi t·∫£i l√™n h√¨nh ·∫£nh:', error);

    // X√≥a file ƒë√£ t·∫£i l√™n n·∫øu x·ª≠ l√Ω th·∫•t b·∫°i
    if (req.file.path && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫£i l√™n h√¨nh ·∫£nh'
    });
  }
};

/**
 * API t·∫°o m·∫´u √¢m thanh ƒë·ªÉ nghe th·ª≠ gi·ªçng ƒë·ªçc
 */
const generateSampleAudio = async (req, res) => {
  console.log('üîä B·∫Øt ƒë·∫ßu t·∫°o m·∫´u √¢m thanh gi·ªçng ƒë·ªçc...');

  const { text, voiceId } = req.body;

  if (!text || !voiceId) {
    return res.status(400).json({
      success: false,
      error: 'Thi·∫øu n·ªôi dung vƒÉn b·∫£n ho·∫∑c ID gi·ªçng ƒë·ªçc'
    });
  }

  try {
    // T·∫°o th∆∞ m·ª•c l∆∞u tr·ªØ
    const audioDir = path.join(__dirname, '../../public/temp/audio');
    if (!fs.existsSync(audioDir)) {
      fs.mkdirSync(audioDir, { recursive: true });
    }

    // ƒê∆∞·ªùng d·∫´n file ƒë·∫ßu ra
    const audioFilename = `sample_${voiceId}_${Date.now()}.mp3`;
    const outputPath = path.join(audioDir, audioFilename);

    // T·∫°o gi·ªçng ƒë·ªçc m·∫´u
    await convertTextToSpeech(text, outputPath, voiceId);

    return res.json({
      success: true,
      audioUrl: `/temp/audio/${audioFilename}`,
      text: text
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi t·∫°o m·∫´u √¢m thanh:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫°o m·∫´u √¢m thanh'
    });
  }
};

const renderEditPartsPage = (req, res) => {
  res.render('videoView/editVideoParts', {
    title: 'Ch·ªânh s·ª≠a ph·∫ßn video',
    layout: 'main'
  });
};

// controllers/videoController.js
const createFinalVideo = async (req, res) => {
  try {
    /* ------------------------------------------------
       0. L·∫§Y INPUT
    -------------------------------------------------*/
    const {
      sessionId,
      parts,
      music,
      musicVolume = 0.5,
      musicStartTime = 0,
      musicEndTime = null
    } = req.body;


    if (!sessionId || !Array.isArray(parts) || parts.length === 0) {
      return res.status(400).json({ success: false, error: 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá' });
    }

    /* ------------------------------------------------
       1. CHU·∫®N B·ªä TH∆Ø M·ª§C & T√äN FILE
    -------------------------------------------------*/
    const outputDir = path.join(__dirname, '../../public/videos');
    if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

    const videoFileName = `advanced_video_${Date.now()}.mp4`;
    const outputPath = path.join(outputDir, videoFileName);

    /* ------------------------------------------------
       2. L·ªåC & T·∫†O SEGMENTS
    -------------------------------------------------*/
    const validParts = parts.filter(p => p.imagePath && p.audioPath);
    if (!validParts.length) {
      return res.status(400).json({ success: false, error: 'Kh√¥ng c√≥ ph·∫ßn n√†o ƒë·ªß media' });
    }

    const segTxt = path.join(outputDir, `segments_${Date.now()}.txt`);
    const segments = [];
    let segContent = '';

    for (let i = 0; i < validParts.length; i++) {
      const p = validParts[i];
      const segPath = path.join(outputDir, `segment_${i}_${Date.now()}.mp4`);
      segments.push(segPath);

      /* scale/pad tu·ª≥ t·ªâ l·ªá */
      const scaleMap = {
        '9:16': '-vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2"',
        '1:1': '-vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:(ow-iw)/2:(oh-ih)/2"',
        '4:3': '-vf "scale=1440:1080:force_original_aspect_ratio=decrease,pad=1440:1080:(ow-iw)/2:(oh-ih)/2"',
        '16:9': '-vf "scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2"'
      };
      const segSetting = scaleMap[aspectRatio] || scaleMap['16:9'];

      /* caption tu·ª≥ √Ω */
      let caption = '';
      if (p.caption) {
        const safeTxt = p.caption.replace(/'/g, '\\\'');
        const yPos =
          p.captionPosition === 'top' ? 'text_h' :
            p.captionPosition === 'bottom' ? 'h-text_h*2' :
              '(h-text_h)/2';
        caption = `,drawtext=text='${safeTxt}':fontcolor=white:fontsize=36:x=(w-text_w)/2:y=${yPos}:shadowcolor=black:shadowx=2:shadowy=2`;
      }

      const cmd = `ffmpeg -y -loop 1 -i "${p.imagePath}" -i "${p.audioPath}" `
        + `-c:v libx264 -tune stillimage -c:a aac -b:a 192k -af "volume=1.0" `
        + `${segSetting}${caption} -pix_fmt yuv420p -shortest "${segPath}"`;
      execSync(cmd, { stdio: 'inherit' });
      segContent += `file '${segPath.replace(/\\/g, '/')}'\n`;
    }
    fs.writeFileSync(segTxt, segContent);

    /* ------------------------------------------------
       3. GH√âP SEGMENT + FASTSTART
    -------------------------------------------------*/
    const sizeMap = { '9:16': '1080x1920', '1:1': '1080x1080', '4:3': '1440x1080', '16:9': '1920x1080' };
    const concatCmd =
      `ffmpeg -y -f concat -safe 0 -i "${segTxt}" -c:v libx264 -c:a aac `
      + `-pix_fmt yuv420p -movflags +faststart -s ${sizeMap[aspectRatio] || sizeMap['16:9']} "${outputPath}"`;
    execSync(concatCmd, { stdio: 'inherit' });

    /* ------------------------------------------------
       4. SUBTITLE
    -------------------------------------------------*/
    const srtPath = path.join(outputDir, 'subs.srt');
    generateSrtFile(validParts, srtPath);

    const srtTmp = path.join(outputDir, `subs_${Date.now()}.srt`);
    fs.copyFileSync(srtPath, srtTmp);
    const escSrt = srtTmp.replace(/\\/g, '/').replace(/:/g, '\\:');
    const tempOut = path.join(outputDir, `render_${Date.now()}.mp4`);
    const subCmd = `ffmpeg -y -i "${outputPath}" -vf "subtitles='${escSrt}'" -c:a copy "${tempOut}"`;
    execSync(subCmd, { stdio: 'inherit' });
    fs.renameSync(tempOut, outputPath);

    /* ------------------------------------------------
       5. UPLOAD FIREBASE
    -------------------------------------------------*/
    const firebaseKey = `videos/${videoFileName}`;
    const publicUrl = await uploadFile(
      outputPath,
      firebaseKey,
      { contentType: 'video/mp4' }          // ƒë·ªÉ tr√¨nh duy·ªát stream OK
    );
    console.log('üöÄ Upload Firebase th√†nh c√¥ng:', publicUrl);

    /* (t√πy ch·ªçn) ghi DB --------------------------------*/
    const stats = fs.statSync(outputPath);
    const sizeMb = (stats.size / 1024 / 1024).toFixed(2);
    const userId =
      req.session?.user?.id_nguoidung
      || req.user?.id_nguoidung
      || null;

    await videoModel.insertVideo({
      filename, firebaseKey, publicUrl, sizeMb,
      title, script, userId
    });

    //fs.copyFileSync(subtitledOutputTemp, outputPath);
    // === Th√™m nh·∫°c n·ªÅn n·∫øu c√≥ ch·ªçn ===
    if (music) {
      await addMusicToVideo(outputPath, outputPath, music, musicVolume, musicStartTime, musicEndTime, outputDir);
    }


    /* ------------------------------------------------
       6. D·ªåN FILE T·∫†M & TR·∫¢ K·∫æT QU·∫¢
    -------------------------------------------------*/
    [...segments, segTxt, srtPath, srtTmp].forEach(f => fs.existsSync(f) && fs.unlinkSync(f));

    // fs.unlinkSync(outputPath); // n·∫øu mu·ªën xo√° file local

    return res.json({
      success: true,
      videoUrl: publicUrl,            // URL Firebase c√≥ th·ªÉ embed ngay
      localPath: `/videos/${videoFileName}`
    });

  } catch (err) {
    console.error('‚ùå L·ªói createFinalVideo:', err);
    return res.status(500).json({ success: false, error: err.message });
  }
};

// Ki·ªÉm tra c√†i ƒë·∫∑t ban ƒë·∫ßu
const checkSetup = async (req, res) => {
  try {
    const checks = {
      ffmpeg: false,
      ffprobe: false,
      googleCredentials: false,
      tempDir: false,
      videoDir: false
    };

    // Ki·ªÉm tra FFmpeg
    try {
      execSync('ffmpeg -version');
      checks.ffmpeg = true;
    } catch (error) {
      console.error('FFmpeg kh√¥ng ƒë∆∞·ª£c c√†i ƒë·∫∑t:', error.message);
    }

    // Ki·ªÉm tra FFprobe
    try {
      execSync('ffprobe -version');
      checks.ffprobe = true;
    } catch (error) {
      console.error('FFprobe kh√¥ng ƒë∆∞·ª£c c√†i ƒë·∫∑t:', error.message);
    }

    // Ki·ªÉm tra Google credentials
    const ttsCredentialsPath = path.join(__dirname, '../../text to speed.json');
    if (fs.existsSync(ttsCredentialsPath)) {
      checks.googleCredentials = true;
    }

    // Ki·ªÉm tra th∆∞ m·ª•c
    const tempDir = path.join(__dirname, '../../public/temp');
    const videoDir = path.join(__dirname, '../../public/videos');

    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    checks.tempDir = fs.existsSync(tempDir);

    if (!fs.existsSync(videoDir)) {
      fs.mkdirSync(videoDir, { recursive: true });
    }
    checks.videoDir = fs.existsSync(videoDir);

    return res.json({
      success: true,
      checks
    });
  } catch (error) {
    console.error('L·ªói khi ki·ªÉm tra c√†i ƒë·∫∑t:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra c√†i ƒë·∫∑t'
    });
  }
};

// Th√™m API debug video
const debugVideo = async (req, res) => {
  try {
    // Ki·ªÉm tra th∆∞ m·ª•c v√† file
    const debugInfo = {
      system: {
        platform: process.platform,
        architecture: process.arch,
        nodeVersion: process.version,
        memory: process.memoryUsage()
      },
      directories: {},
      files: {},
      ffmpeg: {},
      credentials: {}
    };

    // Ki·ªÉm tra th∆∞ m·ª•c
    const baseDir = path.join(__dirname, '../../');
    const dirsToCheck = [
      'public',
      'public/videos',
      'public/temp',
      'public/temp/audio'
    ];

    for (const dir of dirsToCheck) {
      const fullPath = path.join(baseDir, dir);
      let status = 'kh√¥ng t·ªìn t·∫°i';
      let writable = false;

      if (fs.existsSync(fullPath)) {
        status = 't·ªìn t·∫°i';
        try {
          // Ki·ªÉm tra quy·ªÅn ghi
          const testFile = path.join(fullPath, `test_${Date.now()}.txt`);
          fs.writeFileSync(testFile, 'test');
          fs.unlinkSync(testFile);
          writable = true;
        } catch (error) {
          writable = false;
        }
      } else {
        try {
          fs.mkdirSync(fullPath, { recursive: true });
          status = 'ƒë√£ t·∫°o m·ªõi';
          writable = true;
        } catch (error) {
          status = `l·ªói khi t·∫°o: ${error.message}`;
        }
      }

      debugInfo.directories[dir] = {
        path: fullPath,
        status,
        writable
      };
    }

    // Ki·ªÉm tra file credentials
    const credentialsFile = path.join(baseDir, 'text to speed.json');
    if (fs.existsSync(credentialsFile)) {
      const stats = fs.statSync(credentialsFile);
      debugInfo.credentials['text to speed.json'] = {
        exists: true,
        size: stats.size,
        permissions: fs.constants.R_OK | fs.constants.W_OK ? 'ƒë·ªçc/ghi' : 'kh√¥ng ƒë·ªß quy·ªÅn',
        validJson: true
      };

      try {
        const content = fs.readFileSync(credentialsFile, 'utf8');
        JSON.parse(content);
      } catch (error) {
        debugInfo.credentials['text to speed.json'].validJson = false;
      }
    } else {
      debugInfo.credentials['text to speed.json'] = {
        exists: false,
        message: 'File credentials kh√¥ng t·ªìn t·∫°i'
      };
    }

    // Ki·ªÉm tra FFmpeg
    try {
      const ffmpegVersion = execSync('ffmpeg -version').toString();
      const ffprobeVersion = execSync('ffprobe -version').toString();

      debugInfo.ffmpeg = {
        ffmpeg: {
          installed: true,
          version: ffmpegVersion.split('\n')[0]
        },
        ffprobe: {
          installed: true,
          version: ffprobeVersion.split('\n')[0]
        }
      };
    } catch (error) {
      debugInfo.ffmpeg = {
        error: error.message,
        solution: 'C√†i ƒë·∫∑t FFmpeg v√† th√™m v√†o PATH'
      };
    }

    // Ki·ªÉm tra k·∫øt n·ªëi Internet (ƒë·ªÉ t·∫£i h√¨nh ·∫£nh)
    try {
      const axios = require('axios');
      const internetCheck = await axios.get('https://www.google.com', { timeout: 5000 });
      debugInfo.internet = {
        connected: internetCheck.status === 200,
        status: internetCheck.status
      };
    } catch (error) {
      debugInfo.internet = {
        connected: false,
        error: error.message
      };
    }

    return res.json({
      success: true,
      debugInfo
    });
  } catch (error) {
    console.error('L·ªói khi ki·ªÉm tra debug video:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra debug video'
    });
  }
};

module.exports = {
  generateAdvancedVideo,
  getAvailableVoices,
  prepareVideoScript,
  generateImageForPart,
  generateAudioForPart,
  finalizeAdvancedVideo,
  uploadImageForPart,
  generateSampleAudio,
  upload, // Export middleware upload ƒë·ªÉ s·ª≠ d·ª•ng trong router
  renderEditPartsPage,
  createFinalVideo,
  checkSetup,
  debugVideo,
  uploadAudioForPart,
  upload      ,   // middleware h√¨nh ·∫£nh
  audioUpload 
};